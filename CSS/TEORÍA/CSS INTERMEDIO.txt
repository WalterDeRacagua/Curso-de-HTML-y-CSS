CSS INTERMEDIO
----------------

1.SELECTORES AVANZADOS
-----------------------
Debemos saber cómo dar estilo a los elementos. Pero la otra parte de css, además de dar estilo, consiste en saber SELECCIONAR aquello que queremos modificar. Hay muchas formas en las que podemos tener problemas a la hora de seleccionar elementos en CSS. Saber seleccionar elementos en momentos específicos, en algunos estados, o elementos hijos, hermanos...

1-DAR ESTILO POR ATRIBUTO

Por ejemplo, seleccionar a una etiqueta que, como atributo tenga el src de una imagen concreta:img[scr="FaviconRM.png"]{
    width: 100%;
}

Si queremos por ejemplo seleccionar todas las que tengan .png como extensión lo podemos hacer poniendo el simbolo del dollar $ justo después del atributo de la siguiente manera:

img[src$=".png"]{
    width: 100%;
}

Si queremos aplicar una propiedad a un atributo que empieza de cierta forma usamos ^ :
img[src^="FaviconRM"]{
    width: 50%;
}

2-SELECTORES DESCENDENTES

Si por ejemplo queremos que una propiedad afecte a todas las etiquetas que estén dentro de una etiqueta concreta. Por ejemplo, que el color de letra rojo a los list ítems <li> sea para aquellos li que forman parte de una unordered list <ul>:

ul li{
    color: #f00;
}

Con esto decimos que li tiene que estar adentro de ul. 

Pero si queremos estilo solamente a los hijos y NO a los nietos (no a todos los elementos que estén dentro). Para ello, tenemos que poner el símbolo >:

ul > li{
    color: #f00;
}

Aunque en ese caso CREO que también afecta a los nietos. Ahí se ha confundido.


3-SELECTOR (DE HERMANO) ADYACENTE

Selecciona el elemento que está a continuación mía. Únicamente seleccionamos al elemento de JUSTO DESPUÉS. Para ello hacemos uso de +:

h1 + p{
    color: #00f;
}


4-SELECTOR DE HERMANOS GENERALES

Si queremos darle estilo a todas las etiquetas que se encuentren después de cierta etiqueta tenemos que usar el símbolo ~ de la siguiente forma:

h1 ~ p{
    color: #00f;
}

Se estilizan los <p> que se encuentren después de la etiqueta h1 en este caso.

5- SELECTOR DE MÚLTIPLES ELEMENTOS

Para estilizar elementos con cierta etiqueta; ya lo hemos visto anteriormente:

h1,p{
    color: #000;
}


2-HERENCIA
------------

Concepto de POO. Algunas propiedades pueden heredarse y otras NO pueden. Eso es la herencia. Si por ejemplo el body tiene la siguiente propiedad:

body{
    color: brown;
}

Todos los elementos sin estilo que se encuentren dentro de la etiqueta body heredarán esa propiedad. En concreto, el color SI se puede heredar.

Sin embargo, hay otras propiedades como puede ser el width que NO se heredan.

div{
    width: 50%;
}

En este caso, no haría efecto a los elementos de dentro del div.

Pero podemos modificar el comportamiento de la herencia en CSS.

Si queremos que un elemento herede una propiedad de su padre podemos hacer lo siguiente con algunas características (usar INHERIT->HEREDA):

h1{
    color: inherit;
}

inherit es el valor por defecto. Pero si h1 tiene un color distinto, usa el color definido en h1 en vez de el del padre que heredaría.

Como widht no es una propiedad heredable podemos hacer que h1 la herede poniéndolo nosotros de la siguiente forma:

h1{
    color: inherit;
    width: inherit;
}

Si por ejemplo tenemos el h1 dentro de un div, y no le hemos puesto width a div, a pesar de que no se lo hayamos definido, seguiría heredando el width predefinido de div.

Si lo que queremos hacer es que h1 NO herede el color por ejemplo, o cualquier otra propiedad, lo que tenemos que hacer es usar initial:

h1{
    /*Si queremos que lo herede ponemos inherit*/
    color: inherit;
    width: inherit;
    /*Si no queremos que lo herede ponemos initial*/
    color: initial;
}

Reestablece el valor al valor por defecto.
Luego tenemos unset que lo que hace es que si el valor por defecto era inherit, lo vuelve a inherit, pero si era otro, lo deja en initial.

Normalmente initial, unset y demás NO se utiliza. Inherit se utiliza por ejemplo en los text-areas o las etiquetas del formulario. Usar la herencia de una manera correcta, como hemos hecho en la carrera.


input, textarea{
    width: 100%;
    /*Para que se adapte a la pantalla usamos lo siguiente*/
    box-sizing: border-box;
    padding: 6px 8px;
    border: 2px solid #555;
    border-radius: 5px;
    box-shadow: 0 0 15px 0 #0001;
    background: transparent;
    color: #eee;
    font-family: inherit;
}

Así definimos la Font-family una sola vez para todos los elementos!

3. CASCADA Y ESPECIFIDAD
-------------------------

CSS significa hojas de estilo en cascada. Es un concepto muy importante.

Podemos concebir la especifidad como la puntuación de un estilo. Si a un elemento le decimos que tiene que ser rojo y después decimos que tiene que ser azul... ¿de qué color va a ser? La especifidad y la cascada se encargan de solucionar estos conflictos que ocurren al sobreescribir propiedades.

La cascada es un concepto que dice que el orden en el que ponemos las propiedades a los elementos SI IMPORTA. 

Si ponemos el cursor encima de la etiqueta aparece la especifidad del selector: Especificidad del selector: (0, 0, 1). Si ponemos a h1 dos colores va a poner el último que pongas:

h1{
    color: #f00;
}

h1{
    color: #00f;
}

Cuando la especifidad es exactamente igual, la propiedad que va a quedar es la última que apliquemos. Ambas tienen especifidad (0,0,1).

¿Qué pasa si un elemento tiene más especifidad? Significa que un elemento es más específico. HTML tiene configurado para que nosotros podamos determinar la especifidad de un elemento.

Si a h1 le asignamos una clase y cambiamos al estilo de esa clase, es más específico la clase que la etiqueta:
<h1 class="titulo">TITULO PRINCIPAL</h1>

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar de que h1 va después, como .titulo es más específico, el color será el de .titulo. La especifidad de la clase .titulo es:Especificidad del selector: (0, 1, 0) (10, más específico que 1). El valor que más importa es el primero. La forma de ser más específico todavía es usando el id:
<h1 class="titulo" id="titulo">TITULO PRINCIPAL</h1>
#titulo{
    color: #0f0;
}

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar que es el primero que pongo, como el id es más especifico: Especificidad del selector: (1, 0, 0) coge el color que hemos puesto haciendo referencia al id. El primer número es el más importante, el segundo es el siguiente más importante. El último el que menos importa. podemos verlo con el tercero tiene especifidad 100, el segundo 10 y el tercero 1.

Ahora, hay un nivel superior de especifidad al de los ids.
Que es ponerle el estilo en línea:<h1 class="titulo" id="titulo" style="color:violet">TITULO PRINCIPAL</h1>
Al poner el style color, es más especifico que hacerlo en css. Ver la imagen de la cascada de especifidad que he hecho.

Poniendo !important en CSS el resto deja de hacer efecto.

h1{
    color: #00f !important;
}

Sigue las normas generales de especifidad:
.titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

h1{
    color: #00f !important;
}

A pesar de que ambos tienen important, como .titulo al ser una clase es más especifico que la etiqueta h1, el color será el de la clase! En este caso rojo.

Si seleccionamos a la clase que está dentro de la etiqueta body:
body .titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
La especifidad es:Especificidad del selector: (0, 1, 1), es más específico que (0,1,0).

4. PSEUDOCLASES
-----------------

Nos permiten seleccionar un estado específico de un elemento que seleccionamos.
Son palabras clave, que nos permiten seleccionar un estado específico de un elemento.

Una de las pseudoclases más comunes es :hover. El estado que selecciona es el que cuando tenemos el ratón/cursor encima del elemento:

h1{
    color: #48e;
    font-family: sans-serif;
    margin: 30px;
}

h1:hover{
    color:#000;
}

En este caso, al pasar el ratón por encima, el color del h1 será negro. hover es el más utilizado.

También tenemos :active: define el color de un elemento cuando le damos al click.

Estas dos son las más usadas.

Si tenemos una lista de elementos de unordered list, con 4 list ítems, si queremos cambiar el color del primer li podemos hacer uso de la pseudoclase :first-child:

li:first-child{
    color: #f00;
}

Solo cambia el primer li. Para cambiar el último:

/*SELECCIONANDO EL ÚLTIMO LI*/
li:last-child{
    color: #00f;
}

Para seleccionar cualquier hijo que NO sea ni el primero ni el último tenemos que hacer uso de nth-child(enesimo):

/*SELECCIONANDO EL ENESIMO LI*/
li:nth-child(2){
    color: #f00;
}

También podemos modificar todos los elementos li que ocupan posiciones pares, posiciones impares...

/*SELECCIONAMOS LOS ELEMENTOS PARES (o de dos en dos)*/
li:nth-child(2n){
    color: brown;
}

Esto último es muy utilizado para tablas.

Si por ejemplo ponemos otro elemento entre los li que no es un li (p.ej un span), con nth-child, si queremos seleccionar el segundo li tenemos que usar nth-child(3) porque cuenta el span como un elemento a pesar de que NO podamos modificarlo. 
Para seguir el orden normal de los elementos usamos nth-on-type():
/*SELECCIONAMOS EL SEGUNDO ELEMENTO DE TIPO LI*/
/*EN ESTE CASO TENEMOS UN SPAN, SI PUSIERAMOS nth-child(2) no funciona, tendríamos que poner 3 */
li:nth-of-type(2){
    
}

Si ponemos ul li es menos especifico que si ponemos la clase .lista li. Ahí si que nos deja cambiarlo:
/*SELECCIONAMOS TODOS LOS LI DEL UL*/
.lista li{
    color: #fff;
}

Otra pseudoclase utilizada es :not(). Si no queremos darle una propiedad a un elemento li concreto, a este le ponemos una clase y hacemos lo siguiente:

/*SELECCIONAR TODOS LOS LI MENOS EL 4º*/
.lista li:not(.elem-4){
    color: #fff;
}

Para seleccionar un elemento SOLAMENTE en el caso de que esté vacío, utilizamos la pseudo-clase :empty. Para que esté vacía la etiqueta div no podemos dejar espacio:

<div></div>

/*SELECCIONAR ELEMENTO SOLO CUANDO ESTE VACÍO*/
div:empty{
    background: #0f0;
    padding: 30px;
}

Esta propiedad es útil, si por ejemplo queremos que haga algo cuando este vacío.

Después tenemos la pseudo-clase root. Selecciona al elemento raíz. Las propiedades del elemento raíz que sean heredables las heredaran el resto según la especificidad. Este en teoría él no lo utiliza mucho.

Podemos cambiar a un input según el estado. Cambiar por ejemplo un checkbox:
/*Cuando el input es de tipoi checkbox*/
input[type="checkbox"]{
    margin: 50px;
}

/*PARA COMPROBAR QUE EL CHECKBOX ESTE SELECCIONADO*/
input[type="checkbox"]:checked{
    margin: auto;
}

De está forma, si el checkbox está marcado tendrá margin auto, sino margin de 30px.

Si queremos modificar un enlace que NO ha sido modificado usamos para la etiqueta a la pseudoclase :link.

/*SELECCIONANDO ENLACES NO VISITADOS*/
a:link{
    color: red;
}

Si queremos modificar un enlace que YA HA SIDO VISITADO, usamos la pseudoclase :visited

/*SELECCIONANDO ENLACES VISITADOS*/
a:visited{
    color: #0f0;
}

Para ver más pseudoclases, buscar mdn pseudoclases en el buscador de Google.

Una importante también es :focus. Buscarlo en la web que nombro arriba.

Otro es invalid, que si un input no tiene info valida por ejemplo, cambia el texto de color...:
/*Para algo que no es valido*/
/*En este caso el email no es valido*/
input:invalid{
    color: red;
}

También está el :valid	

5. IS, WHERE, HAS
--------------------

Son pseudoclases que han salido hace poco. SI hacemos lo siguiente:

section .elemento1,
section .elemento2,
section .elemento3{
    color: #f00;
}

Conseguimos que, los elementos que tengan dichas clases, tengan la tipografía de ese color. Pero... ¿cómo podemos hacer esto más fácil? De la siguiente forma:

section :is(.elemento1, .elemento2, .elemento3){
    color: blue;
}

Esto es análogo a lo de arriba. Es necesario dejar espacio entre section y : (es cierto que no es necesario poner section la verdad).

Usar where es menos específico que usar is y lo primero. Is cambia la especificidad y where NO la cambia.

En cuanto a has es una pseudoclase que se da al elemento padre, y si se pone sin espacio padre:has.

Comprueba que una etiqueta tenga un elemento o clase concreta para que ocurra algo.

/*HAS*/
/*NO HAY QUE DEJAR ESPACIO. EN ESTE CASO SI LA SECCION CONTIENE EL ELEMENTO 1 LE DAMOS EL BG NEGRO*/
section:has(.elemento1){
    background: #000;
}

Podemos combinar conocimientos y hacer lo siguiente:

/*COMBINANDO CONOCIMIENTOS PODEMOS HACER LO SIGUIENTE*/
/*VAMOS A MODIFICAR EL UL QUE CONTENGA DESPUÉS UN DIV*/
ul:has(+div){
    background: #000;
}

En el caso de que a ul le siga un div, modificamos el ul.

Podemos hacer lo siguiente también:

/*PODEMOS HACER ESTO PARA MODIFICAR EL COLOR DEL LABEL EN EL CASO DE QUE EL INPUT SEA VALID O TAMBIÉN INVALID.*/
label:has(input:valid){
    color: #0f0;
}

Y para poder cambiar también el input podemos hacer lo siguiente:
/*RECOMIENDA DARLE A LOS INPUT COLOR:INHERIT PARA PODER HACER QUE HEREDE DE LABEL EL COLOR Y SI ES CORRECTO SE PONDRÁ VERDE Y SI NO ROJO*/
input{
    color: inherit;
}


6.PSEUDO-ELEMENTOS
--------------------

Para cambiar el estilo de elementos como por ejemplo un placeholder, o los puntos de una unordered list… usamos los pseudo-elementos.

Los pseudo-elementos representan partes especificas de elementos.

Para representar los pseudo-elementos usamos :: dos dobles puntos.

El primer pseudo-elemento que tenemos es h1::first-letter, selecciona la primera letra del h1

h1::first-letter{
    color: #f00;
    font-size: 3em;
    letter-spacing: -10px;
}

Si queremos únicamente modificar la primera línea de un elemento hacemos ::first-line.

div::first-line{
    color: #f0f;
}

Modificaremos la primera linea de todos los divs.

Si por ejemplo queremos cambiar el fondo de un elemento que NOSOTROS SELECCIONAMOS CON EL RATÓN, HACEMOS LO SIGUIENTE:

h1::selection{
    background: #0ff;
}

ver vídeo que he guardado.

Los pseudo-elementos tienen sus dificultades. No podemos darle margin, o padding o display por ejemplo. Hay que tener en cuenta estás consideraciones.

Para modificar el placeholder, podemos hacer lo siguiente:

input::placeholder{
    color: #00f;
}

Para cambiar de los li el circulito de su izquierda podemos hacer lo siguiente:

li::marker{
    color: #f00;
}

Si queremos poner un texto antes de un elemento, en este caso un li hacemos uso de ::before:

li::before{
    content: 'texto antes';
}

Si queremos hacer cualquier cosa DESPUÉS de un elemento, en este caso un li, podemos hacer lo siguiente:

li::after{
    content: ' despues';
    color: #00f;
}

Con esto ya tenemos suficiente con los pseudo-elementos. En total hay 10 pseudo-elementos. Before y after se suelen utilizar mucho.

7. METODOLOGÍA BEM
---------------------

Es una forma de trabajar con nuestros proyectos. Importante tener siempre una metodología de trabajar.

BEM viene de "Block Element Modifier" bloques, elementos y modificadores.

Metodología = forma específica de trabajar.

El principal objetivo de BEM es reutilizar código.

Por ejemplo, siempre darle las mismas características a un botón. Ver foto guardada en la práctica.

BEM consiste en tener una base para los elementos y después con los modificadores ir modificándolos para los distintos elementos. Así no tenemos que reutilizar código.

Además, se resuelven problemas de especificidad. 

BEM permite saber cómo escribir código y cómo nombrar a las clases para solamente viéndolas saber que hacen y que significan.

Y tiene código más legible.

(B)loque(E)lemento(M)odificador

	-Bloque: Componente que no depende de nadie para existir. Una barra de navegación. El formulario que ya hicimos... ya que lo podemos reutilizar en cualquier lugar de la página.

	-Elemento: Hace referencia a una parte de un bloque. Un pedazo/trozo del bloque que, si lo sacamos del bloque no tiene sentido, pero si lo dejamos dentro si lo tiene. Por ejemplo, en la barra de navegación de Google, si sacamos los elementos de esa barra de navegación no tiene sentido. Tiene sentido dentro. Ver vídeo

	-Modificadores: Forma de modificar un bloque o un elemento. Si queremos que un bloque/elemento sea distinto que otro tenemos que modificarlo. Para eso agregamos CLASES MODIFICADORAS para modificarlo.

PD: Para cambiar el estilo de los elementos de una lista hacemos list-style y cambiamos a cuadrados, o lo que nosotros queramos.

SI NO APLICAMOS LA METODOLOGÍA BEM:

/*FORMA INCORRECTA DE APLICAR LA METODLOGÍA BEM*/
.lista{
    border: 2px solid #000;
}

.ingrediente{
    color: #777;
    margin: 10px 0;
    list-style:square;
}

.ingrediente-importante{
    color: #00f;
    margin: 10px 0;
    list-style: square ;
}

.ingrediente-danino{
    color: #f00;
    margin: 10px 0;
    list-style: square ;
}

/*HASTA AQUÍ*/

Vemos que se REPITEN líneas de código, y eso NO lo queremos (margin: 10px 0; list-style: square ;)

APLICANDO METODOLOGÍA BEM:

Toda la lista es un bloque, ya que NO depende de nadie para existir. Como la funcionalidad del bloque es ser una lista, entonces añadimos clase lista al ul:<ul class="lista"> y para los elementos que conforman la lista podemos poner lista + dos guiones bajos + nombre elemento: lista__item:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

Pero nos falta añadir los modificadores. Ya que queríamos aclarar que la sal era dañina y la harina importante. Para ello, en la misma clase ponemos un espacio, empezamos con el final y añadimos el tipo de elemento que es. Por ejemplo, queríamos decir que la sal es dañina, lo hacemos así: 

 <li class="lista__item item--danino">

O que la harina es importante:

 <li class="lista__item item--importante" >

Se nos quedaría este código muchísimo más claro:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

.item--danino{
    color: #f00;
}
Aplicar esta metodología siempre. Ahora podemos crear nuevas listas y que estás tengan el mismo estilo. Si queremos modificar una lista, podemos modificar y hacer lo siguiente:

 <ul class="lista lista--vieja">
        <li class="lista__item item--danino">
            Sal
        </li>
        <li class="lista__item">
            Patata
        </li>
        <li class="lista__item item--importante" >
            Harina
        </li>
        <li class="lista__item">
            Agua
        </li>
    </ul>

.lista--vieja{
    opacity: 0.5;
    background: #ddd;
}


Lo único que tenemos que hacer para modificar es añadir un modificador a la clase y hacer los cambios pertinentes.

Utilizar esta metodología para consumir menos recursos, trabajar bien con la especificidad y evitar la repetición de código.

8.PROPIEDAD DISPLAY
----------------------

	