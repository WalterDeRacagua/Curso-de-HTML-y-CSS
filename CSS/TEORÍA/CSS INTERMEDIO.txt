CSS INTERMEDIO
----------------

1.SELECTORES AVANZADOS
-----------------------
Debemos saber cómo dar estilo a los elementos. Pero la otra parte de css, además de dar estilo, consiste en saber SELECCIONAR aquello que queremos modificar. Hay muchas formas en las que podemos tener problemas a la hora de seleccionar elementos en CSS. Saber seleccionar elementos en momentos específicos, en algunos estados, o elementos hijos, hermanos...

1-DAR ESTILO POR ATRIBUTO

Por ejemplo, seleccionar a una etiqueta que, como atributo tenga el src de una imagen concreta:img[scr="FaviconRM.png"]{
    width: 100%;
}

Si queremos por ejemplo seleccionar todas las que tengan .png como extensión lo podemos hacer poniendo el simbolo del dollar $ justo después del atributo de la siguiente manera:

img[src$=".png"]{
    width: 100%;
}

Si queremos aplicar una propiedad a un atributo que empieza de cierta forma usamos ^ :
img[src^="FaviconRM"]{
    width: 50%;
}

2-SELECTORES DESCENDENTES

Si por ejemplo queremos que una propiedad afecte a todas las etiquetas que estén dentro de una etiqueta concreta. Por ejemplo, que el color de letra rojo a los list ítems <li> sea para aquellos li que forman parte de una unordered list <ul>:

ul li{
    color: #f00;
}

Con esto decimos que li tiene que estar adentro de ul. 

Pero si queremos estilo solamente a los hijos y NO a los nietos (no a todos los elementos que estén dentro). Para ello, tenemos que poner el símbolo >:

ul > li{
    color: #f00;
}

Aunque en ese caso CREO que también afecta a los nietos. Ahí se ha confundido.


3-SELECTOR (DE HERMANO) ADYACENTE

Selecciona el elemento que está a continuación mía. Únicamente seleccionamos al elemento de JUSTO DESPUÉS. Para ello hacemos uso de +:

h1 + p{
    color: #00f;
}


4-SELECTOR DE HERMANOS GENERALES

Si queremos darle estilo a todas las etiquetas que se encuentren después de cierta etiqueta tenemos que usar el símbolo ~ de la siguiente forma:

h1 ~ p{
    color: #00f;
}

Se estilizan los <p> que se encuentren después de la etiqueta h1 en este caso.

5- SELECTOR DE MÚLTIPLES ELEMENTOS

Para estilizar elementos con cierta etiqueta; ya lo hemos visto anteriormente:

h1,p{
    color: #000;
}


2-HERENCIA
------------

Concepto de POO. Algunas propiedades pueden heredarse y otras NO pueden. Eso es la herencia. Si por ejemplo el body tiene la siguiente propiedad:

body{
    color: brown;
}

Todos los elementos sin estilo que se encuentren dentro de la etiqueta body heredarán esa propiedad. En concreto, el color SI se puede heredar.

Sin embargo, hay otras propiedades como puede ser el width que NO se heredan.

div{
    width: 50%;
}

En este caso, no haría efecto a los elementos de dentro del div.

Pero podemos modificar el comportamiento de la herencia en CSS.

Si queremos que un elemento herede una propiedad de su padre podemos hacer lo siguiente con algunas características (usar INHERIT->HEREDA):

h1{
    color: inherit;
}

inherit es el valor por defecto. Pero si h1 tiene un color distinto, usa el color definido en h1 en vez de el del padre que heredaría.

Como widht no es una propiedad heredable podemos hacer que h1 la herede poniéndolo nosotros de la siguiente forma:

h1{
    color: inherit;
    width: inherit;
}

Si por ejemplo tenemos el h1 dentro de un div, y no le hemos puesto width a div, a pesar de que no se lo hayamos definido, seguiría heredando el width predefinido de div.

Si lo que queremos hacer es que h1 NO herede el color por ejemplo, o cualquier otra propiedad, lo que tenemos que hacer es usar initial:

h1{
    /*Si queremos que lo herede ponemos inherit*/
    color: inherit;
    width: inherit;
    /*Si no queremos que lo herede ponemos initial*/
    color: initial;
}

Reestablece el valor al valor por defecto.
Luego tenemos unset que lo que hace es que si el valor por defecto era inherit, lo vuelve a inherit, pero si era otro, lo deja en initial.

Normalmente initial, unset y demás NO se utiliza. Inherit se utiliza por ejemplo en los text-areas o las etiquetas del formulario. Usar la herencia de una manera correcta, como hemos hecho en la carrera.


input, textarea{
    width: 100%;
    /*Para que se adapte a la pantalla usamos lo siguiente*/
    box-sizing: border-box;
    padding: 6px 8px;
    border: 2px solid #555;
    border-radius: 5px;
    box-shadow: 0 0 15px 0 #0001;
    background: transparent;
    color: #eee;
    font-family: inherit;
}

Así definimos la Font-family una sola vez para todos los elementos!

3. CASCADA Y ESPECIFIDAD
-------------------------

CSS significa hojas de estilo en cascada. Es un concepto muy importante.

Podemos concebir la especifidad como la puntuación de un estilo. Si a un elemento le decimos que tiene que ser rojo y después decimos que tiene que ser azul... ¿de qué color va a ser? La especifidad y la cascada se encargan de solucionar estos conflictos que ocurren al sobreescribir propiedades.

La cascada es un concepto que dice que el orden en el que ponemos las propiedades a los elementos SI IMPORTA. 

Si ponemos el cursor encima de la etiqueta aparece la especifidad del selector: Especificidad del selector: (0, 0, 1). Si ponemos a h1 dos colores va a poner el último que pongas:

h1{
    color: #f00;
}

h1{
    color: #00f;
}

Cuando la especifidad es exactamente igual, la propiedad que va a quedar es la última que apliquemos. Ambas tienen especifidad (0,0,1).

¿Qué pasa si un elemento tiene más especifidad? Significa que un elemento es más específico. HTML tiene configurado para que nosotros podamos determinar la especifidad de un elemento.

Si a h1 le asignamos una clase y cambiamos al estilo de esa clase, es más específico la clase que la etiqueta:
<h1 class="titulo">TITULO PRINCIPAL</h1>

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar de que h1 va después, como .titulo es más específico, el color será el de .titulo. La especifidad de la clase .titulo es:Especificidad del selector: (0, 1, 0) (10, más específico que 1). El valor que más importa es el primero. La forma de ser más específico todavía es usando el id:
<h1 class="titulo" id="titulo">TITULO PRINCIPAL</h1>
#titulo{
    color: #0f0;
}

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar que es el primero que pongo, como el id es más especifico: Especificidad del selector: (1, 0, 0) coge el color que hemos puesto haciendo referencia al id. El primer número es el más importante, el segundo es el siguiente más importante. El último el que menos importa. podemos verlo con el tercero tiene especifidad 100, el segundo 10 y el tercero 1.

Ahora, hay un nivel superior de especifidad al de los ids.
Que es ponerle el estilo en línea:<h1 class="titulo" id="titulo" style="color:violet">TITULO PRINCIPAL</h1>
Al poner el style color, es más especifico que hacerlo en css. Ver la imagen de la cascada de especifidad que he hecho.

Poniendo !important en CSS el resto deja de hacer efecto.

h1{
    color: #00f !important;
}

Sigue las normas generales de especifidad:
.titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

h1{
    color: #00f !important;
}

A pesar de que ambos tienen important, como .titulo al ser una clase es más especifico que la etiqueta h1, el color será el de la clase! En este caso rojo.

Si seleccionamos a la clase que está dentro de la etiqueta body:
body .titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
La especifidad es:Especificidad del selector: (0, 1, 1), es más específico que (0,1,0).

4. PSEUDOCLASES
-----------------

Nos permiten seleccionar un estado específico de un elemento que seleccionamos.
Son palabras clave, que nos permiten seleccionar un estado específico de un elemento.

Una de las pseudoclases más comunes es :hover. El estado que selecciona es el que cuando tenemos el ratón/cursor encima del elemento:

h1{
    color: #48e;
    font-family: sans-serif;
    margin: 30px;
}

h1:hover{
    color:#000;
}

En este caso, al pasar el ratón por encima, el color del h1 será negro. hover es el más utilizado.

También tenemos :active: define el color de un elemento cuando le damos al click.

Estas dos son las más usadas.

Si tenemos una lista de elementos de unordered list, con 4 list ítems, si queremos cambiar el color del primer li podemos hacer uso de la pseudoclase :first-child:

li:first-child{
    color: #f00;
}

Solo cambia el primer li. Para cambiar el último:

/*SELECCIONANDO EL ÚLTIMO LI*/
li:last-child{
    color: #00f;
}

Para seleccionar cualquier hijo que NO sea ni el primero ni el último tenemos que hacer uso de nth-child(enesimo):

/*SELECCIONANDO EL ENESIMO LI*/
li:nth-child(2){
    color: #f00;
}

También podemos modificar todos los elementos li que ocupan posiciones pares, posiciones impares...

/*SELECCIONAMOS LOS ELEMENTOS PARES (o de dos en dos)*/
li:nth-child(2n){
    color: brown;
}

Esto último es muy utilizado para tablas.

Si por ejemplo ponemos otro elemento entre los li que no es un li (p.ej un span), con nth-child, si queremos seleccionar el segundo li tenemos que usar nth-child(3) porque cuenta el span como un elemento a pesar de que NO podamos modificarlo. 
Para seguir el orden normal de los elementos usamos nth-on-type():
/*SELECCIONAMOS EL SEGUNDO ELEMENTO DE TIPO LI*/
/*EN ESTE CASO TENEMOS UN SPAN, SI PUSIERAMOS nth-child(2) no funciona, tendríamos que poner 3 */
li:nth-of-type(2){
    
}

Si ponemos ul li es menos especifico que si ponemos la clase .lista li. Ahí si que nos deja cambiarlo:
/*SELECCIONAMOS TODOS LOS LI DEL UL*/
.lista li{
    color: #fff;
}

Otra pseudoclase utilizada es :not(). Si no queremos darle una propiedad a un elemento li concreto, a este le ponemos una clase y hacemos lo siguiente:

/*SELECCIONAR TODOS LOS LI MENOS EL 4º*/
.lista li:not(.elem-4){
    color: #fff;
}

Para seleccionar un elemento SOLAMENTE en el caso de que esté vacío, utilizamos la pseudo-clase :empty. Para que esté vacía la etiqueta div no podemos dejar espacio:

<div></div>

/*SELECCIONAR ELEMENTO SOLO CUANDO ESTE VACÍO*/
div:empty{
    background: #0f0;
    padding: 30px;
}

Esta propiedad es útil, si por ejemplo queremos que haga algo cuando este vacío.

Después tenemos la pseudo-clase root. Selecciona al elemento raíz. Las propiedades del elemento raíz que sean heredables las heredaran el resto según la especificidad. Este en teoría él no lo utiliza mucho.

Podemos cambiar a un input según el estado. Cambiar por ejemplo un checkbox:
/*Cuando el input es de tipoi checkbox*/
input[type="checkbox"]{
    margin: 50px;
}

/*PARA COMPROBAR QUE EL CHECKBOX ESTE SELECCIONADO*/
input[type="checkbox"]:checked{
    margin: auto;
}

De está forma, si el checkbox está marcado tendrá margin auto, sino margin de 30px.

Si queremos modificar un enlace que NO ha sido modificado usamos para la etiqueta a la pseudoclase :link.

/*SELECCIONANDO ENLACES NO VISITADOS*/
a:link{
    color: red;
}

Si queremos modificar un enlace que YA HA SIDO VISITADO, usamos la pseudoclase :visited

/*SELECCIONANDO ENLACES VISITADOS*/
a:visited{
    color: #0f0;
}

Para ver más pseudoclases, buscar mdn pseudoclases en el buscador de Google.

Una importante también es :focus. Buscarlo en la web que nombro arriba.

Otro es invalid, que si un input no tiene info valida por ejemplo, cambia el texto de color...:
/*Para algo que no es valido*/
/*En este caso el email no es valido*/
input:invalid{
    color: red;
}

También está el :valid	

5. IS, WHERE, HAS
--------------------

Son pseudoclases que han salido hace poco. SI hacemos lo siguiente:

section .elemento1,
section .elemento2,
section .elemento3{
    color: #f00;
}

Conseguimos que, los elementos que tengan dichas clases, tengan la tipografía de ese color. Pero... ¿cómo podemos hacer esto más fácil? De la siguiente forma:

section :is(.elemento1, .elemento2, .elemento3){
    color: blue;
}

Esto es análogo a lo de arriba. Es necesario dejar espacio entre section y : (es cierto que no es necesario poner section la verdad).

Usar where es menos específico que usar is y lo primero. Is cambia la especificidad y where NO la cambia.

En cuanto a has es una pseudoclase que se da al elemento padre, y si se pone sin espacio padre:has.

Comprueba que una etiqueta tenga un elemento o clase concreta para que ocurra algo.

/*HAS*/
/*NO HAY QUE DEJAR ESPACIO. EN ESTE CASO SI LA SECCION CONTIENE EL ELEMENTO 1 LE DAMOS EL BG NEGRO*/
section:has(.elemento1){
    background: #000;
}

Podemos combinar conocimientos y hacer lo siguiente:

/*COMBINANDO CONOCIMIENTOS PODEMOS HACER LO SIGUIENTE*/
/*VAMOS A MODIFICAR EL UL QUE CONTENGA DESPUÉS UN DIV*/
ul:has(+div){
    background: #000;
}

En el caso de que a ul le siga un div, modificamos el ul.

Podemos hacer lo siguiente también:

/*PODEMOS HACER ESTO PARA MODIFICAR EL COLOR DEL LABEL EN EL CASO DE QUE EL INPUT SEA VALID O TAMBIÉN INVALID.*/
label:has(input:valid){
    color: #0f0;
}

Y para poder cambiar también el input podemos hacer lo siguiente:
/*RECOMIENDA DARLE A LOS INPUT COLOR:INHERIT PARA PODER HACER QUE HEREDE DE LABEL EL COLOR Y SI ES CORRECTO SE PONDRÁ VERDE Y SI NO ROJO*/
input{
    color: inherit;
}


6.PSEUDO-ELEMENTOS
--------------------

Para cambiar el estilo de elementos como por ejemplo un placeholder, o los puntos de una unordered list… usamos los pseudo-elementos.

Los pseudo-elementos representan partes especificas de elementos.

Para representar los pseudo-elementos usamos :: dos dobles puntos.

El primer pseudo-elemento que tenemos es h1::first-letter, selecciona la primera letra del h1

h1::first-letter{
    color: #f00;
    font-size: 3em;
    letter-spacing: -10px;
}

Si queremos únicamente modificar la primera línea de un elemento hacemos ::first-line.

div::first-line{
    color: #f0f;
}

Modificaremos la primera linea de todos los divs.

Si por ejemplo queremos cambiar el fondo de un elemento que NOSOTROS SELECCIONAMOS CON EL RATÓN, HACEMOS LO SIGUIENTE:

h1::selection{
    background: #0ff;
}

ver vídeo que he guardado.

Los pseudo-elementos tienen sus dificultades. No podemos darle margin, o padding o display por ejemplo. Hay que tener en cuenta estás consideraciones.

Para modificar el placeholder, podemos hacer lo siguiente:

input::placeholder{
    color: #00f;
}

Para cambiar de los li el circulito de su izquierda podemos hacer lo siguiente:

li::marker{
    color: #f00;
}

Si queremos poner un texto antes de un elemento, en este caso un li hacemos uso de ::before:

li::before{
    content: 'texto antes';
}

Si queremos hacer cualquier cosa DESPUÉS de un elemento, en este caso un li, podemos hacer lo siguiente:

li::after{
    content: ' despues';
    color: #00f;
}

Con esto ya tenemos suficiente con los pseudo-elementos. En total hay 10 pseudo-elementos. Before y after se suelen utilizar mucho.

7. METODOLOGÍA BEM
---------------------

Es una forma de trabajar con nuestros proyectos. Importante tener siempre una metodología de trabajar.

BEM viene de "Block Element Modifier" bloques, elementos y modificadores.

Metodología = forma específica de trabajar.

El principal objetivo de BEM es reutilizar código.

Por ejemplo, siempre darle las mismas características a un botón. Ver foto guardada en la práctica.

BEM consiste en tener una base para los elementos y después con los modificadores ir modificándolos para los distintos elementos. Así no tenemos que reutilizar código.

Además, se resuelven problemas de especificidad. 

BEM permite saber cómo escribir código y cómo nombrar a las clases para solamente viéndolas saber que hacen y que significan.

Y tiene código más legible.

(B)loque(E)lemento(M)odificador

	-Bloque: Componente que no depende de nadie para existir. Una barra de navegación. El formulario que ya hicimos... ya que lo podemos reutilizar en cualquier lugar de la página.

	-Elemento: Hace referencia a una parte de un bloque. Un pedazo/trozo del bloque que, si lo sacamos del bloque no tiene sentido, pero si lo dejamos dentro si lo tiene. Por ejemplo, en la barra de navegación de Google, si sacamos los elementos de esa barra de navegación no tiene sentido. Tiene sentido dentro. Ver vídeo

	-Modificadores: Forma de modificar un bloque o un elemento. Si queremos que un bloque/elemento sea distinto que otro tenemos que modificarlo. Para eso agregamos CLASES MODIFICADORAS para modificarlo.

PD: Para cambiar el estilo de los elementos de una lista hacemos list-style y cambiamos a cuadrados, o lo que nosotros queramos.

SI NO APLICAMOS LA METODOLOGÍA BEM:

/*FORMA INCORRECTA DE APLICAR LA METODLOGÍA BEM*/
.lista{
    border: 2px solid #000;
}

.ingrediente{
    color: #777;
    margin: 10px 0;
    list-style:square;
}

.ingrediente-importante{
    color: #00f;
    margin: 10px 0;
    list-style: square ;
}

.ingrediente-danino{
    color: #f00;
    margin: 10px 0;
    list-style: square ;
}

/*HASTA AQUÍ*/

Vemos que se REPITEN líneas de código, y eso NO lo queremos (margin: 10px 0; list-style: square ;)

APLICANDO METODOLOGÍA BEM:

Toda la lista es un bloque, ya que NO depende de nadie para existir. Como la funcionalidad del bloque es ser una lista, entonces añadimos clase lista al ul:<ul class="lista"> y para los elementos que conforman la lista podemos poner lista + dos guiones bajos + nombre elemento: lista__item:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

Pero nos falta añadir los modificadores. Ya que queríamos aclarar que la sal era dañina y la harina importante. Para ello, en la misma clase ponemos un espacio, empezamos con el final y añadimos el tipo de elemento que es. Por ejemplo, queríamos decir que la sal es dañina, lo hacemos así: 

 <li class="lista__item item--danino">

O que la harina es importante:

 <li class="lista__item item--importante" >

Se nos quedaría este código muchísimo más claro:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

.item--danino{
    color: #f00;
}
Aplicar esta metodología siempre. Ahora podemos crear nuevas listas y que estás tengan el mismo estilo. Si queremos modificar una lista, podemos modificar y hacer lo siguiente:

 <ul class="lista lista--vieja">
        <li class="lista__item item--danino">
            Sal
        </li>
        <li class="lista__item">
            Patata
        </li>
        <li class="lista__item item--importante" >
            Harina
        </li>
        <li class="lista__item">
            Agua
        </li>
    </ul>

.lista--vieja{
    opacity: 0.5;
    background: #ddd;
}


Lo único que tenemos que hacer para modificar es añadir un modificador a la clase y hacer los cambios pertinentes.

Utilizar esta metodología para consumir menos recursos, trabajar bien con la especificidad y evitar la repetición de código.

8.PROPIEDAD DISPLAY
----------------------

En este apartado vamos a ver qué es display y la importancia de usarlo.

Si tenemos dos <a> (enlaces) y no ponemos nada de display, entonces salen uno seguido del otro.

Pero si ponemos display:block; entonces sale uno debajo del otro:


a{
    background: #f00;
    color: #fff;
    display: block;
}

Cuando ponemos display block hacemos que ocupe todo el ancho disponible. Además, comienza una nueva línea.

Estos elementos de bloque aceptan márgenes, padding… Si quitamos el display block y hacemos zoom se superpone uno encima del otro, pero si lo dejamos sigue apareciendo uno debajo del otro.

Lo que hacemos con display es transformar un elemento de línea en un elemento de bloque.

Luego, también podemos hacer que elementos de bloque pasen a ser elementos en línea. Usando display: inline; por ejemplo, para p que es un elemento de bloque:
p{
    background: #111;
    color: #fff;
    display: inline;
}

Los elementos en línea solo se modifican a lo ancho, no podemos cambiarle el height ni nada...

Por ejemplo, para las tablas <table>, el display es table, y para las celdas su display es table-cell.

Otro tipo de display muy usado también es inline-block, que es una mezcla entre ambas. Se usa, por ejemplo, para realizar barras de navegación.

.nav__item{
    display: inline-block;
    padding: 10px;
    background: #48e;
}

Además, podemos hacerlo aun más bonito si añadimos a cada item, a cada list element una pseudoclase :hover para que, cuando pasemos el mouse por encima, salga de otro color:

.nav__item:hover{
    background: #6af;
}

.nav__link{
    color: #fff;
    text-decoration: none;
    font-family: sans-serif;
}

Y ya tendríamos nuestra barra de navegación. 

Si por ejemplo quisiéramos que un enlace sea un botón, aplicando la metodología BEM podemos añadirle un modificador al enlace:
     <a href="" class="nav__link link--button">

Y de esta forma nos puede quedar un botón bastante bonito para una barra de navegación:

.link--button{
    border:1px solid #fff;
    background: #fff;
    padding: 6px 12px;
    color: #48e;
    border-radius: 12px;  
}

.link--button:hover{
    background: transparent;     
    color: #fff;       
}

Por tanto, display: inline-block nos sirve para este tipo de cosas.

El último valor que le podemos dar a display es none. Si nosotros le ponemos el display none al botón desaparece:

.link--button{
    border:1px solid #fff;
    background: #fff;
    padding: 6px 12px;
    color: #48e;
    border-radius: 12px; 
    margin-left: 24px; 
    display: none;
}

El resto de elementos se comportan como si este NO estuviera.

Veremos display flex-box y otro display que es lo que se usa siempre.

9. POSITION RELATIVA
--------------------------

Veremos dos valores de la propiedad position.

Nos permite posicionar elementos. Los valores son relative y absolute.

Posicionar un elemento consiste en crear un contexto de apilamiento; objetivo: separar una capa de otras capas. 

Con una aplicación llamada Blender ha mostrado en que consiste este posicionamiento. Básicamente en superponer unos elementos o capas sobre otras.

Positio relative es como decirle al navegador que el elemento mantenga su posición original en la página pero si quiero, puedo moverlo hacia arriba, abajo, izquierda...
No solo eso, si no que además vas a ser un punto de referencia para los elementos que estén dentro de ti.

.box{
    width: 100px;
    height: 100px;
    background: #f60;
    position: relative;
}

/*Caja con modificador*/
.box--blue{
    background: #00f;
    /*Con position relative podemos decir que se mueva*/
    top: 5px;
}

Con esto le decimos que podemos mover la caja, y la azul se moverá abajo tantos px como diga.

Si le quitamos position relative NO podemos mover la caja.

Por defecto, position trae el valor de static.

Si añadimos otra caja, empezará justo después del lugar que debería ocupar nuestra caja. El lugar asignado a la caja es fijo, pero la vamos a poder mover, ver el vídeo.

Usar left, top, bottom y right, que es cuanto te vas a mover abajo, arriba, izquierda y derecha... si decimos bottom irá DESDE ABAJO HACIA ARRIBA, y así con todas las propiedades.

Bottom tiene MENOS prioridad que la propiedad TOP. Da igual que pongamos !important o lo que sea que, si definimos ambas, da prioridad a top. Con left y right pasa más de lo mismo, y la prioridad la tiene left sobre right.
Luego poner TOP Y LEFT.

Otra propiedad que aparece IMPORTANTE es el z-index. Nos permite superponer unas cajas sobre otras a través del eje z. Si hemos creado 3 cajas una detrás de otra, la primera creada (en HTML) siempre irá debajo de las demás a no ser que modifiquemos esta propiedad.

.box{
    width: 100px;
    height: 100px;
    background: #f60;
    position: relative;
    z-index: 10;
}

/*Caja con modificador*/
.box--blue{
    background: #00f;
    /*Con position relative podemos decir que se mueva: mainly hacia top y hacia left.*/
    top: 70px;
    left: 20px;
    z-index: 20;
}

El z-index de la azul es mayor que el z-index del resto por tanto se superpondrá sobre el resto. Una buena técnica es dar z-index de 10 en adelante e ir poniéndolo de 10 en 10.

z-index solamente sirve cuando tenemos posicionados los elementos.

10. POSICIÓN ABSOLUTA
-----------------------

La otra forma de posicionar elementos.

Si a un elemento le damos position absolute, lo primero que hace es que ya NO ocupa lugar en la página.

Al poner position absolute vemos que desaparece una caja. Ver vídeo. Pero en realidad sigue estando, es como si la caja 2 se superpusiera sobre la caja 3. Esto se debe a que la caja 2 ya NO OCUPA LUGAR. Si ponemos position:absolute a la azul y top 0 la caja se mueve fuera. En cambio, si ponemos relative, se mantiene dentro de su caja por así decirlo. Position absolute tiene como referencia el comienzo de la etiqueta HTML, que es arriba a la izquierda de la página (No tiene en cuenta el elemento que lo contiene). La podemos mover donde nosotros queramos:

/*Caja con modificador BEM (Bloque elemento modificador)*/
.box--blue{
    background: #48e;
    position: absolute;
    top: 100px;
    left: 200px;
}

Si queremos que el punto de referencia sea el del contenedor que lo contiene tendremos que ponerle a su contenedor POSTION:RELATIVE.

Es por eso que antes habíamos dicho que las cajas que se posicionan como relative FUNCIONAN COMO PUNTOS DE REFERENCIA. Se posiciona como un punto relativo. Si le decimos que se mueva hacia abajo 20 px, lo va a hacer sobre este punto relativo:

.box--blue{
    background: #48e;
    position: absolute;
    top: 20px;
    left: 0;
}

Una cosa que ocurre con el postionn absolute es que, si le ponemos bottom 0, se posiciona debajo de todo. Si ponemos right 0, se posiciona en la derecha del todo.

Por esto es interesante el position absolute, porque se posiciona en las esquinas y demás. La caja relativa tiene sus propios puntos de referencia. 

Sigue ocurriendo que top > bottom y left > right. Pero además aquí surge algo de magia... Si ponemos top 0, left 0 right 0 y bottom 0 y además añadimos margin auto, se posiciona en el centro del contenedor.

.box--blue{
    background: #48e;
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    left: 0;
    margin: auto;
}

Con esto, la caja siempre va a estar centrada. Esta forma de centrar elementos NO LA RECOMIENDO, ya que veremos otra forma de centrarlo, pero esta guay saberlo.

Con relative podemos añadirle el z-index y en position absolute, las posiciones sobre las que se va a desplazar NO son sobre si mismas. Son relativas. Si no hay ningún elemento relativo, lo hará sobre el raíz que es HTML.

Aclarar que las cajas DEBEN ESTAR DENTRO DE SU CONTENEDOR EN HTML.

Vamos a hacer un ejercicio para position absolute. Es muy útil para realizar ventanas modales, aunque ahora apareció el elemento dialog.

11. VENTANAS MODALES
------------------------

Ejercicio en el que usamos position absolute. Es una utilidad. Ya veremos como se hace con la etiqueta dialog.
Utiliza dialog para hacer ventanas emergentes:

<dialog class="modal" open>
        <div class="modal__content">
            <h2 class="modal__title">VENTANA MODAL</h2>
        <p class="modal__text">Lorem ipsum dolor sit amet consectetur adipisicing elit. Totam tempora harum rem dignissimos nemo nulla quam, provident enim cumque? Sequi dolores minus dolore iste quisquam similique, amet nostrum at accusamus.
        </p>
        <button class="modal__close-button">X</button>
        </div>
    </dialog>

Open es para que aparezca abierta. Si no queremos programar el código del botón con JavaScript debemos utilizar dialog open y encerrar el button en un formulario con method= "dialog":

    <dialog open>
        <div class="modal__content">
            <h2 class="modal__title">VENTANA MODAL</h2>
        <form method="dialog">
            <button class="modal__close-button">X</button>
        </form>
        </div>
    </dialog>

Además, en CSS usando dialog podemos quitar la posición absoluta SI Y SOLO SI USAMOS DIALOG, usando un div como antes debemos de usarlo para colocarlo en la esquina superior derecha.

Usando dialog tampoco sería necesario usar la propiedad background, porque podemos usar el pseudo-elemento dialog::backdrop. INVESTIGAR TODO SOBRE BACKDROP PARA DAR ESTILO A TODO LO DE DETRÁS DE UN DIALOG.


12. POSICIONES FIJA Y STICKY
--------------------------------

Nuevos tipos de position. FIJA = FIXED. 

Si ponemos position fixed ocurre lo mismo que cuando ponemos position absolute. Esto pasa si no ponemos nada mas. Sin embargo, si lo metemos dentro de un contenedor con position relative NO VA A RESPETARLO COMO HACE ABSOLUTE. Respeta siempre la position relative de la raíz, en este caso HTML, que empieza arriba del todo a la izquierda.

Además de esa diferencia, otra diferencia enorme es, que cuando nosotros scrolleamos la pantalla, la cajita sigue fija, sin moverse. Puede ser interesante para poner que es una notificación y poner en CSS lo siguiente:

.box{
    height: 60px;
    width: 200px;
    background: #fff;
    position:fixed;
    right: 0;
    border: 1px solid #000;
    border-right: 0;
    box-shadow: 0 0 40px 0 #0009;
}

Podemos usarlo para poder tener un chat en nuestra página por ejemplo.

El otro position es position sticky. Lo que hace es que, cuando llega a cierta posición, se queda pegado. Por ejemplo:
.box-fixed{
    height: 60px;
    width: 200px;
    background: #f00;
    position:sticky;
    top: 20px;
}
Cuando toca top deja 20 px y se queda pegado arriba, ver vídeo. Es decir cuando top es de 20px se va a comportar como fixed.