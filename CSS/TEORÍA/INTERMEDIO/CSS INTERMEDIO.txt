CSS INTERMEDIO
----------------

1.SELECTORES AVANZADOS
-----------------------
Debemos saber cómo dar estilo a los elementos. Pero la otra parte de css, además de dar estilo, consiste en saber SELECCIONAR aquello que queremos modificar. Hay muchas formas en las que podemos tener problemas a la hora de seleccionar elementos en CSS. Saber seleccionar elementos en momentos específicos, en algunos estados, o elementos hijos, hermanos...

1-DAR ESTILO POR ATRIBUTO

Por ejemplo, seleccionar a una etiqueta que, como atributo tenga el src de una imagen concreta:img[scr="FaviconRM.png"]{
    width: 100%;
}

Si queremos por ejemplo seleccionar todas las que tengan .png como extensión lo podemos hacer poniendo el simbolo del dollar $ justo después del atributo de la siguiente manera:

img[src$=".png"]{
    width: 100%;
}

Si queremos aplicar una propiedad a un atributo que empieza de cierta forma usamos ^ :
img[src^="FaviconRM"]{
    width: 50%;
}

2-SELECTORES DESCENDENTES

Si por ejemplo queremos que una propiedad afecte a todas las etiquetas que estén dentro de una etiqueta concreta. Por ejemplo, que el color de letra rojo a los list ítems <li> sea para aquellos li que forman parte de una unordered list <ul>:

ul li{
    color: #f00;
}

Con esto decimos que li tiene que estar adentro de ul. 

Pero si queremos estilo solamente a los hijos y NO a los nietos (no a todos los elementos que estén dentro). Para ello, tenemos que poner el símbolo >:

ul > li{
    color: #f00;
}

Aunque en ese caso CREO que también afecta a los nietos. Ahí se ha confundido.


3-SELECTOR (DE HERMANO) ADYACENTE

Selecciona el elemento que está a continuación mía. Únicamente seleccionamos al elemento de JUSTO DESPUÉS. Para ello hacemos uso de +:

h1 + p{
    color: #00f;
}


4-SELECTOR DE HERMANOS GENERALES

Si queremos darle estilo a todas las etiquetas que se encuentren después de cierta etiqueta tenemos que usar el símbolo ~ de la siguiente forma:

h1 ~ p{
    color: #00f;
}

Se estilizan los <p> que se encuentren después de la etiqueta h1 en este caso.

5- SELECTOR DE MÚLTIPLES ELEMENTOS

Para estilizar elementos con cierta etiqueta; ya lo hemos visto anteriormente:

h1,p{
    color: #000;
}


2-HERENCIA
------------

Concepto de POO. Algunas propiedades pueden heredarse y otras NO pueden. Eso es la herencia. Si por ejemplo el body tiene la siguiente propiedad:

body{
    color: brown;
}

Todos los elementos sin estilo que se encuentren dentro de la etiqueta body heredarán esa propiedad. En concreto, el color SI se puede heredar.

Sin embargo, hay otras propiedades como puede ser el width que NO se heredan.

div{
    width: 50%;
}

En este caso, no haría efecto a los elementos de dentro del div.

Pero podemos modificar el comportamiento de la herencia en CSS.

Si queremos que un elemento herede una propiedad de su padre podemos hacer lo siguiente con algunas características (usar INHERIT->HEREDA):

h1{
    color: inherit;
}

inherit es el valor por defecto. Pero si h1 tiene un color distinto, usa el color definido en h1 en vez de el del padre que heredaría.

Como widht no es una propiedad heredable podemos hacer que h1 la herede poniéndolo nosotros de la siguiente forma:

h1{
    color: inherit;
    width: inherit;
}

Si por ejemplo tenemos el h1 dentro de un div, y no le hemos puesto width a div, a pesar de que no se lo hayamos definido, seguiría heredando el width predefinido de div.

Si lo que queremos hacer es que h1 NO herede el color por ejemplo, o cualquier otra propiedad, lo que tenemos que hacer es usar initial:

h1{
    /*Si queremos que lo herede ponemos inherit*/
    color: inherit;
    width: inherit;
    /*Si no queremos que lo herede ponemos initial*/
    color: initial;
}

Reestablece el valor al valor por defecto.
Luego tenemos unset que lo que hace es que si el valor por defecto era inherit, lo vuelve a inherit, pero si era otro, lo deja en initial.

Normalmente initial, unset y demás NO se utiliza. Inherit se utiliza por ejemplo en los text-areas o las etiquetas del formulario. Usar la herencia de una manera correcta, como hemos hecho en la carrera.


input, textarea{
    width: 100%;
    /*Para que se adapte a la pantalla usamos lo siguiente*/
    box-sizing: border-box;
    padding: 6px 8px;
    border: 2px solid #555;
    border-radius: 5px;
    box-shadow: 0 0 15px 0 #0001;
    background: transparent;
    color: #eee;
    font-family: inherit;
}

Así definimos la Font-family una sola vez para todos los elementos!

3. CASCADA Y ESPECIFIDAD
-------------------------

CSS significa hojas de estilo en cascada. Es un concepto muy importante.

Podemos concebir la especifidad como la puntuación de un estilo. Si a un elemento le decimos que tiene que ser rojo y después decimos que tiene que ser azul... ¿de qué color va a ser? La especifidad y la cascada se encargan de solucionar estos conflictos que ocurren al sobreescribir propiedades.

La cascada es un concepto que dice que el orden en el que ponemos las propiedades a los elementos SI IMPORTA. 

Si ponemos el cursor encima de la etiqueta aparece la especifidad del selector: Especificidad del selector: (0, 0, 1). Si ponemos a h1 dos colores va a poner el último que pongas:

h1{
    color: #f00;
}

h1{
    color: #00f;
}

Cuando la especifidad es exactamente igual, la propiedad que va a quedar es la última que apliquemos. Ambas tienen especifidad (0,0,1).

¿Qué pasa si un elemento tiene más especifidad? Significa que un elemento es más específico. HTML tiene configurado para que nosotros podamos determinar la especifidad de un elemento.

Si a h1 le asignamos una clase y cambiamos al estilo de esa clase, es más específico la clase que la etiqueta:
<h1 class="titulo">TITULO PRINCIPAL</h1>

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar de que h1 va después, como .titulo es más específico, el color será el de .titulo. La especifidad de la clase .titulo es:Especificidad del selector: (0, 1, 0) (10, más específico que 1). El valor que más importa es el primero. La forma de ser más específico todavía es usando el id:
<h1 class="titulo" id="titulo">TITULO PRINCIPAL</h1>
#titulo{
    color: #0f0;
}

.titulo{
    color: #f00;
}

h1{
    color: #00f;
}

A pesar que es el primero que pongo, como el id es más especifico: Especificidad del selector: (1, 0, 0) coge el color que hemos puesto haciendo referencia al id. El primer número es el más importante, el segundo es el siguiente más importante. El último el que menos importa. podemos verlo con el tercero tiene especifidad 100, el segundo 10 y el tercero 1.

Ahora, hay un nivel superior de especifidad al de los ids.
Que es ponerle el estilo en línea:<h1 class="titulo" id="titulo" style="color:violet">TITULO PRINCIPAL</h1>
Al poner el style color, es más especifico que hacerlo en css. Ver la imagen de la cascada de especifidad que he hecho.

Poniendo !important en CSS el resto deja de hacer efecto.

h1{
    color: #00f !important;
}

Sigue las normas generales de especifidad:
.titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

h1{
    color: #00f !important;
}

A pesar de que ambos tienen important, como .titulo al ser una clase es más especifico que la etiqueta h1, el color será el de la clase! En este caso rojo.

Si seleccionamos a la clase que está dentro de la etiqueta body:
body .titulo{
    color: #f00 !important;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
La especifidad es:Especificidad del selector: (0, 1, 1), es más específico que (0,1,0).

4. PSEUDOCLASES
-----------------

Nos permiten seleccionar un estado específico de un elemento que seleccionamos.
Son palabras clave, que nos permiten seleccionar un estado específico de un elemento.

Una de las pseudoclases más comunes es :hover. El estado que selecciona es el que cuando tenemos el ratón/cursor encima del elemento:

h1{
    color: #48e;
    font-family: sans-serif;
    margin: 30px;
}

h1:hover{
    color:#000;
}

En este caso, al pasar el ratón por encima, el color del h1 será negro. hover es el más utilizado.

También tenemos :active: define el color de un elemento cuando le damos al click.

Estas dos son las más usadas.

Si tenemos una lista de elementos de unordered list, con 4 list ítems, si queremos cambiar el color del primer li podemos hacer uso de la pseudoclase :first-child:

li:first-child{
    color: #f00;
}

Solo cambia el primer li. Para cambiar el último:

/*SELECCIONANDO EL ÚLTIMO LI*/
li:last-child{
    color: #00f;
}

Para seleccionar cualquier hijo que NO sea ni el primero ni el último tenemos que hacer uso de nth-child(enesimo):

/*SELECCIONANDO EL ENESIMO LI*/
li:nth-child(2){
    color: #f00;
}

También podemos modificar todos los elementos li que ocupan posiciones pares, posiciones impares...

/*SELECCIONAMOS LOS ELEMENTOS PARES (o de dos en dos)*/
li:nth-child(2n){
    color: brown;
}

Esto último es muy utilizado para tablas.

Si por ejemplo ponemos otro elemento entre los li que no es un li (p.ej un span), con nth-child, si queremos seleccionar el segundo li tenemos que usar nth-child(3) porque cuenta el span como un elemento a pesar de que NO podamos modificarlo. 
Para seguir el orden normal de los elementos usamos nth-on-type():
/*SELECCIONAMOS EL SEGUNDO ELEMENTO DE TIPO LI*/
/*EN ESTE CASO TENEMOS UN SPAN, SI PUSIERAMOS nth-child(2) no funciona, tendríamos que poner 3 */
li:nth-of-type(2){
    
}

Si ponemos ul li es menos especifico que si ponemos la clase .lista li. Ahí si que nos deja cambiarlo:
/*SELECCIONAMOS TODOS LOS LI DEL UL*/
.lista li{
    color: #fff;
}

Otra pseudoclase utilizada es :not(). Si no queremos darle una propiedad a un elemento li concreto, a este le ponemos una clase y hacemos lo siguiente:

/*SELECCIONAR TODOS LOS LI MENOS EL 4º*/
.lista li:not(.elem-4){
    color: #fff;
}

Para seleccionar un elemento SOLAMENTE en el caso de que esté vacío, utilizamos la pseudo-clase :empty. Para que esté vacía la etiqueta div no podemos dejar espacio:

<div></div>

/*SELECCIONAR ELEMENTO SOLO CUANDO ESTE VACÍO*/
div:empty{
    background: #0f0;
    padding: 30px;
}

Esta propiedad es útil, si por ejemplo queremos que haga algo cuando este vacío.

Después tenemos la pseudo-clase root. Selecciona al elemento raíz. Las propiedades del elemento raíz que sean heredables las heredaran el resto según la especificidad. Este en teoría él no lo utiliza mucho.

Podemos cambiar a un input según el estado. Cambiar por ejemplo un checkbox:
/*Cuando el input es de tipoi checkbox*/
input[type="checkbox"]{
    margin: 50px;
}

/*PARA COMPROBAR QUE EL CHECKBOX ESTE SELECCIONADO*/
input[type="checkbox"]:checked{
    margin: auto;
}

De está forma, si el checkbox está marcado tendrá margin auto, sino margin de 30px.

Si queremos modificar un enlace que NO ha sido modificado usamos para la etiqueta a la pseudoclase :link.

/*SELECCIONANDO ENLACES NO VISITADOS*/
a:link{
    color: red;
}

Si queremos modificar un enlace que YA HA SIDO VISITADO, usamos la pseudoclase :visited

/*SELECCIONANDO ENLACES VISITADOS*/
a:visited{
    color: #0f0;
}

Para ver más pseudoclases, buscar mdn pseudoclases en el buscador de Google.

Una importante también es :focus. Buscarlo en la web que nombro arriba.

Otro es invalid, que si un input no tiene info valida por ejemplo, cambia el texto de color...:
/*Para algo que no es valido*/
/*En este caso el email no es valido*/
input:invalid{
    color: red;
}

También está el :valid	

5. IS, WHERE, HAS
--------------------

Son pseudoclases que han salido hace poco. SI hacemos lo siguiente:

section .elemento1,
section .elemento2,
section .elemento3{
    color: #f00;
}

Conseguimos que, los elementos que tengan dichas clases, tengan la tipografía de ese color. Pero... ¿cómo podemos hacer esto más fácil? De la siguiente forma:

section :is(.elemento1, .elemento2, .elemento3){
    color: blue;
}

Esto es análogo a lo de arriba. Es necesario dejar espacio entre section y : (es cierto que no es necesario poner section la verdad).

Usar where es menos específico que usar is y lo primero. Is cambia la especificidad y where NO la cambia.

En cuanto a has es una pseudoclase que se da al elemento padre, y si se pone sin espacio padre:has.

Comprueba que una etiqueta tenga un elemento o clase concreta para que ocurra algo.

/*HAS*/
/*NO HAY QUE DEJAR ESPACIO. EN ESTE CASO SI LA SECCION CONTIENE EL ELEMENTO 1 LE DAMOS EL BG NEGRO*/
section:has(.elemento1){
    background: #000;
}

Podemos combinar conocimientos y hacer lo siguiente:

/*COMBINANDO CONOCIMIENTOS PODEMOS HACER LO SIGUIENTE*/
/*VAMOS A MODIFICAR EL UL QUE CONTENGA DESPUÉS UN DIV*/
ul:has(+div){
    background: #000;
}

En el caso de que a ul le siga un div, modificamos el ul.

Podemos hacer lo siguiente también:

/*PODEMOS HACER ESTO PARA MODIFICAR EL COLOR DEL LABEL EN EL CASO DE QUE EL INPUT SEA VALID O TAMBIÉN INVALID.*/
label:has(input:valid){
    color: #0f0;
}

Y para poder cambiar también el input podemos hacer lo siguiente:
/*RECOMIENDA DARLE A LOS INPUT COLOR:INHERIT PARA PODER HACER QUE HEREDE DE LABEL EL COLOR Y SI ES CORRECTO SE PONDRÁ VERDE Y SI NO ROJO*/
input{
    color: inherit;
}


6.PSEUDO-ELEMENTOS
--------------------

Para cambiar el estilo de elementos como por ejemplo un placeholder, o los puntos de una unordered list… usamos los pseudo-elementos.

Los pseudo-elementos representan partes especificas de elementos.

Para representar los pseudo-elementos usamos :: dos dobles puntos.

El primer pseudo-elemento que tenemos es h1::first-letter, selecciona la primera letra del h1

h1::first-letter{
    color: #f00;
    font-size: 3em;
    letter-spacing: -10px;
}

Si queremos únicamente modificar la primera línea de un elemento hacemos ::first-line.

div::first-line{
    color: #f0f;
}

Modificaremos la primera linea de todos los divs.

Si por ejemplo queremos cambiar el fondo de un elemento que NOSOTROS SELECCIONAMOS CON EL RATÓN, HACEMOS LO SIGUIENTE:

h1::selection{
    background: #0ff;
}

ver vídeo que he guardado.

Los pseudo-elementos tienen sus dificultades. No podemos darle margin, o padding o display por ejemplo. Hay que tener en cuenta estás consideraciones.

Para modificar el placeholder, podemos hacer lo siguiente:

input::placeholder{
    color: #00f;
}

Para cambiar de los li el circulito de su izquierda podemos hacer lo siguiente:

li::marker{
    color: #f00;
}

Si queremos poner un texto antes de un elemento, en este caso un li hacemos uso de ::before:

li::before{
    content: 'texto antes';
}

Si queremos hacer cualquier cosa DESPUÉS de un elemento, en este caso un li, podemos hacer lo siguiente:

li::after{
    content: ' despues';
    color: #00f;
}

Con esto ya tenemos suficiente con los pseudo-elementos. En total hay 10 pseudo-elementos. Before y after se suelen utilizar mucho.

7. METODOLOGÍA BEM
---------------------

Es una forma de trabajar con nuestros proyectos. Importante tener siempre una metodología de trabajar.

BEM viene de "Block Element Modifier" bloques, elementos y modificadores.

Metodología = forma específica de trabajar.

El principal objetivo de BEM es reutilizar código.

Por ejemplo, siempre darle las mismas características a un botón. Ver foto guardada en la práctica.

BEM consiste en tener una base para los elementos y después con los modificadores ir modificándolos para los distintos elementos. Así no tenemos que reutilizar código.

Además, se resuelven problemas de especificidad. 

BEM permite saber cómo escribir código y cómo nombrar a las clases para solamente viéndolas saber que hacen y que significan.

Y tiene código más legible.

(B)loque(E)lemento(M)odificador

	-Bloque: Componente que no depende de nadie para existir. Una barra de navegación. El formulario que ya hicimos... ya que lo podemos reutilizar en cualquier lugar de la página.

	-Elemento: Hace referencia a una parte de un bloque. Un pedazo/trozo del bloque que, si lo sacamos del bloque no tiene sentido, pero si lo dejamos dentro si lo tiene. Por ejemplo, en la barra de navegación de Google, si sacamos los elementos de esa barra de navegación no tiene sentido. Tiene sentido dentro. Ver vídeo

	-Modificadores: Forma de modificar un bloque o un elemento. Si queremos que un bloque/elemento sea distinto que otro tenemos que modificarlo. Para eso agregamos CLASES MODIFICADORAS para modificarlo.

PD: Para cambiar el estilo de los elementos de una lista hacemos list-style y cambiamos a cuadrados, o lo que nosotros queramos.

SI NO APLICAMOS LA METODOLOGÍA BEM:

/*FORMA INCORRECTA DE APLICAR LA METODLOGÍA BEM*/
.lista{
    border: 2px solid #000;
}

.ingrediente{
    color: #777;
    margin: 10px 0;
    list-style:square;
}

.ingrediente-importante{
    color: #00f;
    margin: 10px 0;
    list-style: square ;
}

.ingrediente-danino{
    color: #f00;
    margin: 10px 0;
    list-style: square ;
}

/*HASTA AQUÍ*/

Vemos que se REPITEN líneas de código, y eso NO lo queremos (margin: 10px 0; list-style: square ;)

APLICANDO METODOLOGÍA BEM:

Toda la lista es un bloque, ya que NO depende de nadie para existir. Como la funcionalidad del bloque es ser una lista, entonces añadimos clase lista al ul:<ul class="lista"> y para los elementos que conforman la lista podemos poner lista + dos guiones bajos + nombre elemento: lista__item:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

Pero nos falta añadir los modificadores. Ya que queríamos aclarar que la sal era dañina y la harina importante. Para ello, en la misma clase ponemos un espacio, empezamos con el final y añadimos el tipo de elemento que es. Por ejemplo, queríamos decir que la sal es dañina, lo hacemos así: 

 <li class="lista__item item--danino">

O que la harina es importante:

 <li class="lista__item item--importante" >

Se nos quedaría este código muchísimo más claro:

/*APLICANDO BEM*/

.lista{
    border: 2px solid #000;
}

.lista__item{
    color: #777;
    margin: 10px 0;
    list-style: square;
}

.item--danino{
    color: #f00;
}
Aplicar esta metodología siempre. Ahora podemos crear nuevas listas y que estás tengan el mismo estilo. Si queremos modificar una lista, podemos modificar y hacer lo siguiente:

 <ul class="lista lista--vieja">
        <li class="lista__item item--danino">
            Sal
        </li>
        <li class="lista__item">
            Patata
        </li>
        <li class="lista__item item--importante" >
            Harina
        </li>
        <li class="lista__item">
            Agua
        </li>
    </ul>

.lista--vieja{
    opacity: 0.5;
    background: #ddd;
}


Lo único que tenemos que hacer para modificar es añadir un modificador a la clase y hacer los cambios pertinentes.

Utilizar esta metodología para consumir menos recursos, trabajar bien con la especificidad y evitar la repetición de código.

8.PROPIEDAD DISPLAY
----------------------

En este apartado vamos a ver qué es display y la importancia de usarlo.

Si tenemos dos <a> (enlaces) y no ponemos nada de display, entonces salen uno seguido del otro.

Pero si ponemos display:block; entonces sale uno debajo del otro:


a{
    background: #f00;
    color: #fff;
    display: block;
}

Cuando ponemos display block hacemos que ocupe todo el ancho disponible. Además, comienza una nueva línea.

Estos elementos de bloque aceptan márgenes, padding… Si quitamos el display block y hacemos zoom se superpone uno encima del otro, pero si lo dejamos sigue apareciendo uno debajo del otro.

Lo que hacemos con display es transformar un elemento de línea en un elemento de bloque.

Luego, también podemos hacer que elementos de bloque pasen a ser elementos en línea. Usando display: inline; por ejemplo, para p que es un elemento de bloque:
p{
    background: #111;
    color: #fff;
    display: inline;
}

Los elementos en línea solo se modifican a lo ancho, no podemos cambiarle el height ni nada...

Por ejemplo, para las tablas <table>, el display es table, y para las celdas su display es table-cell.

Otro tipo de display muy usado también es inline-block, que es una mezcla entre ambas. Se usa, por ejemplo, para realizar barras de navegación.

.nav__item{
    display: inline-block;
    padding: 10px;
    background: #48e;
}

Además, podemos hacerlo aun más bonito si añadimos a cada item, a cada list element una pseudoclase :hover para que, cuando pasemos el mouse por encima, salga de otro color:

.nav__item:hover{
    background: #6af;
}

.nav__link{
    color: #fff;
    text-decoration: none;
    font-family: sans-serif;
}

Y ya tendríamos nuestra barra de navegación. 

Si por ejemplo quisiéramos que un enlace sea un botón, aplicando la metodología BEM podemos añadirle un modificador al enlace:
     <a href="" class="nav__link link--button">

Y de esta forma nos puede quedar un botón bastante bonito para una barra de navegación:

.link--button{
    border:1px solid #fff;
    background: #fff;
    padding: 6px 12px;
    color: #48e;
    border-radius: 12px;  
}

.link--button:hover{
    background: transparent;     
    color: #fff;       
}

Por tanto, display: inline-block nos sirve para este tipo de cosas.

El último valor que le podemos dar a display es none. Si nosotros le ponemos el display none al botón desaparece:

.link--button{
    border:1px solid #fff;
    background: #fff;
    padding: 6px 12px;
    color: #48e;
    border-radius: 12px; 
    margin-left: 24px; 
    display: none;
}

El resto de elementos se comportan como si este NO estuviera.

Veremos display flex-box y otro display que es lo que se usa siempre.

9. POSITION RELATIVA
--------------------------

Veremos dos valores de la propiedad position.

Nos permite posicionar elementos. Los valores son relative y absolute.

Posicionar un elemento consiste en crear un contexto de apilamiento; objetivo: separar una capa de otras capas. 

Con una aplicación llamada Blender ha mostrado en que consiste este posicionamiento. Básicamente en superponer unos elementos o capas sobre otras.

Positio relative es como decirle al navegador que el elemento mantenga su posición original en la página pero si quiero, puedo moverlo hacia arriba, abajo, izquierda...
No solo eso, si no que además vas a ser un punto de referencia para los elementos que estén dentro de ti.

.box{
    width: 100px;
    height: 100px;
    background: #f60;
    position: relative;
}

/*Caja con modificador*/
.box--blue{
    background: #00f;
    /*Con position relative podemos decir que se mueva*/
    top: 5px;
}

Con esto le decimos que podemos mover la caja, y la azul se moverá abajo tantos px como diga.

Si le quitamos position relative NO podemos mover la caja.

Por defecto, position trae el valor de static.

Si añadimos otra caja, empezará justo después del lugar que debería ocupar nuestra caja. El lugar asignado a la caja es fijo, pero la vamos a poder mover, ver el vídeo.

Usar left, top, bottom y right, que es cuanto te vas a mover abajo, arriba, izquierda y derecha... si decimos bottom irá DESDE ABAJO HACIA ARRIBA, y así con todas las propiedades.

Bottom tiene MENOS prioridad que la propiedad TOP. Da igual que pongamos !important o lo que sea que, si definimos ambas, da prioridad a top. Con left y right pasa más de lo mismo, y la prioridad la tiene left sobre right.
Luego poner TOP Y LEFT.

Otra propiedad que aparece IMPORTANTE es el z-index. Nos permite superponer unas cajas sobre otras a través del eje z. Si hemos creado 3 cajas una detrás de otra, la primera creada (en HTML) siempre irá debajo de las demás a no ser que modifiquemos esta propiedad.

.box{
    width: 100px;
    height: 100px;
    background: #f60;
    position: relative;
    z-index: 10;
}

/*Caja con modificador*/
.box--blue{
    background: #00f;
    /*Con position relative podemos decir que se mueva: mainly hacia top y hacia left.*/
    top: 70px;
    left: 20px;
    z-index: 20;
}

El z-index de la azul es mayor que el z-index del resto por tanto se superpondrá sobre el resto. Una buena técnica es dar z-index de 10 en adelante e ir poniéndolo de 10 en 10.

z-index solamente sirve cuando tenemos posicionados los elementos.

10. POSICIÓN ABSOLUTA
-----------------------

La otra forma de posicionar elementos.

Si a un elemento le damos position absolute, lo primero que hace es que ya NO ocupa lugar en la página.

Al poner position absolute vemos que desaparece una caja. Ver vídeo. Pero en realidad sigue estando, es como si la caja 2 se superpusiera sobre la caja 3. Esto se debe a que la caja 2 ya NO OCUPA LUGAR. Si ponemos position:absolute a la azul y top 0 la caja se mueve fuera. En cambio, si ponemos relative, se mantiene dentro de su caja por así decirlo. Position absolute tiene como referencia el comienzo de la etiqueta HTML, que es arriba a la izquierda de la página (No tiene en cuenta el elemento que lo contiene). La podemos mover donde nosotros queramos:

/*Caja con modificador BEM (Bloque elemento modificador)*/
.box--blue{
    background: #48e;
    position: absolute;
    top: 100px;
    left: 200px;
}

Si queremos que el punto de referencia sea el del contenedor que lo contiene tendremos que ponerle a su contenedor POSTION:RELATIVE.

Es por eso que antes habíamos dicho que las cajas que se posicionan como relative FUNCIONAN COMO PUNTOS DE REFERENCIA. Se posiciona como un punto relativo. Si le decimos que se mueva hacia abajo 20 px, lo va a hacer sobre este punto relativo:

.box--blue{
    background: #48e;
    position: absolute;
    top: 20px;
    left: 0;
}

Una cosa que ocurre con el postionn absolute es que, si le ponemos bottom 0, se posiciona debajo de todo. Si ponemos right 0, se posiciona en la derecha del todo.

Por esto es interesante el position absolute, porque se posiciona en las esquinas y demás. La caja relativa tiene sus propios puntos de referencia. 

Sigue ocurriendo que top > bottom y left > right. Pero además aquí surge algo de magia... Si ponemos top 0, left 0 right 0 y bottom 0 y además añadimos margin auto, se posiciona en el centro del contenedor.

.box--blue{
    background: #48e;
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    left: 0;
    margin: auto;
}

Con esto, la caja siempre va a estar centrada. Esta forma de centrar elementos NO LA RECOMIENDO, ya que veremos otra forma de centrarlo, pero esta guay saberlo.

Con relative podemos añadirle el z-index y en position absolute, las posiciones sobre las que se va a desplazar NO son sobre si mismas. Son relativas. Si no hay ningún elemento relativo, lo hará sobre el raíz que es HTML.

Aclarar que las cajas DEBEN ESTAR DENTRO DE SU CONTENEDOR EN HTML.

Vamos a hacer un ejercicio para position absolute. Es muy útil para realizar ventanas modales, aunque ahora apareció el elemento dialog.

11. VENTANAS MODALES
------------------------

Ejercicio en el que usamos position absolute. Es una utilidad. Ya veremos como se hace con la etiqueta dialog.
Utiliza dialog para hacer ventanas emergentes:

<dialog class="modal" open>
        <div class="modal__content">
            <h2 class="modal__title">VENTANA MODAL</h2>
        <p class="modal__text">Lorem ipsum dolor sit amet consectetur adipisicing elit. Totam tempora harum rem dignissimos nemo nulla quam, provident enim cumque? Sequi dolores minus dolore iste quisquam similique, amet nostrum at accusamus.
        </p>
        <button class="modal__close-button">X</button>
        </div>
    </dialog>

Open es para que aparezca abierta. Si no queremos programar el código del botón con JavaScript debemos utilizar dialog open y encerrar el button en un formulario con method= "dialog":

    <dialog open>
        <div class="modal__content">
            <h2 class="modal__title">VENTANA MODAL</h2>
        <form method="dialog">
            <button class="modal__close-button">X</button>
        </form>
        </div>
    </dialog>

Además, en CSS usando dialog podemos quitar la posición absoluta SI Y SOLO SI USAMOS DIALOG, usando un div como antes debemos de usarlo para colocarlo en la esquina superior derecha.

Usando dialog tampoco sería necesario usar la propiedad background, porque podemos usar el pseudo-elemento dialog::backdrop. INVESTIGAR TODO SOBRE BACKDROP PARA DAR ESTILO A TODO LO DE DETRÁS DE UN DIALOG.


12. POSICIONES FIJA Y STICKY
--------------------------------

Nuevos tipos de position. FIJA = FIXED. 

Si ponemos position fixed ocurre lo mismo que cuando ponemos position absolute. Esto pasa si no ponemos nada mas. Sin embargo, si lo metemos dentro de un contenedor con position relative NO VA A RESPETARLO COMO HACE ABSOLUTE. Respeta siempre la position relative de la raíz, en este caso HTML, que empieza arriba del todo a la izquierda.

Además de esa diferencia, otra diferencia enorme es, que cuando nosotros scrolleamos la pantalla, la cajita sigue fija, sin moverse. Puede ser interesante para poner que es una notificación y poner en CSS lo siguiente:

.box{
    height: 60px;
    width: 200px;
    background: #fff;
    position:fixed;
    right: 0;
    border: 1px solid #000;
    border-right: 0;
    box-shadow: 0 0 40px 0 #0009;
}

Podemos usarlo para poder tener un chat en nuestra página por ejemplo.

El otro position es position sticky. Lo que hace es que, cuando llega a cierta posición, se queda pegado. Por ejemplo:
.box-fixed{
    height: 60px;
    width: 200px;
    background: #f00;
    position:sticky;
    top: 20px;
}
Cuando toca top deja 20 px y se queda pegado arriba, ver vídeo. Es decir cuando top es de 20px se va a comportar como fixed.

13. TRANSICIONES
--------------------------

Son un intervalo de cambio de una propiedad de un valor a otro. Si ponemos un hover a un cuadrado, al pasar el mouse por encima vemos que se pone de MANERA BRUSCA según nosotros le digamos.

.box{
    width: 200px;
    height: 200px;
    background: #f00;
    margin: auto;
    margin-top: 50px;
    font-size: 20px;
    text-align: center;
}

/*LO QUE PASA AL PASAR EL RATÓN POR ENCIMA*/
.box:hover{
    background: #a22;
    color: #fff;
}

Para hacer que sea más gradual, por ejemplo que pase por todos los colores que hay en el medio para que pase de un estado a otro? SI

Le damos la propiedad a la CAJA QUE VA A TRANSICIONAR, NO AL HOVER. Lo primero es ver que propiedad va a transicionar, transition-property. Y la duración transition-duration 

.box{
    width: 200px;
    height: 200px;
    background: #f00;
    margin: auto;
    margin-top: 50px;
    font-size: 60px;
    text-align: center;
    font-weight: bold;
    transition-property: color;
    transition-duration: 1s;
    transition-delay: 2s;
}

Luego tenemos transtion delay para ver CUÁNTO TARDA EN HACER LA TRANSICIÓN. Le podemos poner todas las propiedades que queremos que transicionen. por ejemplo, el background y el color:

.box{
    width: 200px;
    height: 200px;
    background: #f00;
    margin: auto;
    margin-top: 50px;
    font-size: 60px;
    text-align: center;
    font-weight: bold;
    transition-property: color, background-color;
    transition-duration: 1s;
    /*Lo que tarda en hacer la transición*/
    /*transition-delay: 2s;*/
}

Se separan con comas. Si le aplicamos distintos margins al hover y a la caja puede causar problemas. NO HACER ESTO. TENER MUCHO CUIDADO.

Algo muy interesante son las curvas de Bressier. Ahora lo explicaremos.

Podemos hacer que, cuando toque el usuario el body, cambiar el estilo de la caja.

Podemos hacer que la caja se mueva si pasamos el ratón por encima el body, hacia la derecha si añadimos en transition property left.


.box{
    width: 120px;
    height: 120px;
    background: #f00;
    margin-top: 50px;
    font-size: 60px;
    text-align: center;
    font-weight: bold;
    transition-property: left, background-color;
    transition-duration: 1s;
    /*Lo que tarda en hacer la transición*/
    /*transition-delay: 2s;*/
    color: #f00;
    position: relative;
    left: 0;
}

/*CUANDO PONGAMOS EL MPOUSE SOBRE EL BODY, CAMBIA LA CAJA...*/
body:hover .box{
    background: #00f;
    left: 400px;
}

Si nos fijamos bien, la animación empieza fuerte pero termina despacio, ¿cómo podemos cambiar eso? Con las curvas de breassier. Con la propiedad transition-timing-function:
	- transition-timing-function: ease; es la que viene por defecto.
	- transition-timing-function: easi-in: empieza lento y termina fuerte.
	- transition-timing-function: ease-in-out: empieza y termina lento
	- transition-timing-function_ ease-out

Pero podemos trabajar con las curvas de bezier. Entramos a https://cubic-bezier.com/#.17,.67,.83,.67 . Ahí podemos ver todo eso y si le damos a go aparece como se ven las animaciones. Y lo copiamos aquí según la animación que queramos:

transition-timing-function: cubic-bezier(1,-0.01,0,1.03);

Importante esto. También se puede hacer desde Chrome, pero mejor esa página.

También podemos aunar todas las propiedades de transition en una sola si vamos a usar las tres haciendo lo siguiente:

/*SI QUEREMOS LAS 3 PROPIEDADES EN 1 SOLA LINEA: 1º PROPIEDADES (USAR COMAS), 2º CUANTO TIEMPO DURA LA TRANSICION, 3º CUBIC-BRASIER, 4º DELAY */
    transition: left, background-color, 1s cubic-bezier(.99,0,.43,1) 2s; SOLO USANDO TRANSITION. No hace falta poner la cubic ni el delay, pero si es necesario la propiedad que va a transicionar y la duration.

14. DESBORDAMIENTO-OVERFLOW
-----------------------------

Cómo manejar el contenido que SOBRESALE, DESBORDA de su contenedor. Si en HTML creamos un div que sea una cajita con texto que sobresalga de la caja NO QUEDA BIEN. La caja tiene medidas fijas, tiene alto y ancho de 220px 

.box{
    width: 220px;
    height: 220px;
    background: #fff;
    margin-top: 50px;
    color: #f00;
    position: relative;
    left: 0;
    border: 2px solid #0008;
    margin: auto;
    margin-top: 50px;
}

SIN EMBARGO, SI NO LE DEFINIMOS UN ALTO, EL TAMAÑO SE AJUSTA AL DEL TEXTO. Pero si se lo ponemos se va a estar desbordando.

Esto lo podemos manejar con la propiedad de overflow. Por defecto, el valor de overflow: visible que dice que, lo que sobresalga del contenedor se va a ver, va a ser visible. Pero tenemos otras posibilidades:

	- hidden: se ocultará y si hay información importante, o la que sea NO LA MOSTRARÁ.

	- scroll: Añade una barra de scroll al elemento para que se pueda seguir viendo. Sin embargo, aparecen dos barras de scroll, la que se mueve en el eje x y la que se mueve en el eje-y. Haciendo overflow-x: hidden; podemos eliminar esa barra de scroll. Sin embargo, la mejor forma de hacerlo es con overflow-y: scroll y quitar overflow.

.box{
    width: 220px;
    height: 220px;
    background: #fff;
    margin-top: 50px;
    color: #f00;
    position: relative;
    left: 0;
    border: 2px solid #0008;
    margin: auto;
    margin-top: 50px;
    overflow-y: scroll;
}

Pero esto sigue teniendo un problema, y es que cuando el contenido NO DESBORDE al contenedor, la puta mierda de la barra se va a seguir viendo igual, aunque no se necesita.

Para evitar todo, directamente ponemos overflow:auto; que es de los mejores valores que tiene la propiedad. LA PROPIEDAD OVERFLOW AUTO es la que tienen los text-areas por defecto. 

Otro valor para overflow es overflow:clip; que hace lo mismo que overflow hidden pero NO DEJA ESPACIO PARA LAS BARRAS DE SCROLL. Hidden si que lo deja.

Ahora vamos a ver las porpiedades que se encargan de definir el control del flujo del texto. Lo que acabamos de ver se aplica para todo (imágenes videos)

Lo que vamos a ver ahora es específico para texto.


15. CONTROL DE FLUJO DE TEXTO
-------------------------------

Aquí vemos como tratar ESPECIFICAMENTE EL TEXTO.

La primera propiedad que vemos es white-space, que define CÓMO SE COMPORTAN LOS ESPACIOS EN BLANCO Y LOS SALTOS DE LÍNEA. El valor por defecto es normal.

Luego tenemos el valor nowrap, que lo pone todo en una única línea. No va a ver saltos de línea automáticos. No lo usamos.

Luego tenemos el valor pre, que lo que hace es detectar los saltos de linea TAL CUAL NOSOTROS LOS PONEMOS EN HTML. Es utilizable pero yo no creo que lo usara.

Otro valor de white-space es pre-wrap, que tiene en cuenta cómo lo hayamos puesto nosotros en HTML pero también tiene en cuenta que el contenido se ajuste a los límites. Es parecido al normal. Mezcla entre wrap y normal.

Otra propiedad que tenemos es text-overflow. Si lo que queremos que haga es que muestre los puntos suspensivos podemos hacer es text-overflow: ellipsis de la siguiente manera:

.box{
    width: 240px;
    height: 50px;
    margin: auto;
    margin-top: 50px;
    background: #fff;
    border: 2px solid #0006;
    white-space: nowrap;
    text-overflow:ellipsis ;
    overflow: hidden;
}

También funciona con white-space: pre.

Otra propiedad es word-break. Lo que hace con word-break: break-all; y usando white-space: normal es, si una palabra no cabe, recorta la palabra y pone lo que cabe en una linea y lo que no en la siguiente (lo pone sin guion). Otro valor para word-braek es keep-all para idioma como el coreano. 

Un valor que es bueno pero que está en fase experimental es auto-phrase, que detecta frases inteligentes.

Otra propiedad es overflow-wrap: braek-word que rompe la palabra en silabas si no cabe. El otro valor que le podemos dar es anywhere, que lo que hace es que si la palabra se desborda, la rompe para que no se desborde, solo si la palabra es larga.

También podemos usar text-wrap: balance para que h1 por ejemplo se vea más bonito, balancea el texto para que mas o menos todas las palabras encajen de una forma estética:

h1{
    text-wrap: balance;
}

Luego, otro valor de text-wrap es pretty, que sirve para intentar dejar un texto bonito. Balance es mejor para títulos (h1, h2) mientras que pretty es mejor para textos largos. Pretty evita que una línea se nos quede con una sola palabra.

LO MÁS IMPORTANTE DE TODO ESTO ES LO SIGUIENTE:

1. Si hay algo que se nos va a desbordar, ponemos WHITE-SPACE: nowrap; Le ponemos un text-overflow: ellipsis y overflow:hidden. Si usamos text-wrap: pretty o balance también funciona.

    /*SI SE NOS VA A DESBORDAR ALGO*/
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

2. Si queremos balancear un texto usamos text-wrap balance y para balancear párrafos usamos text-wrap: pretty

.box{
    width: 250px;
    height: 270px;
    margin: auto;
    margin-top: 50px;
    background: #fff;
    border: 2px solid #0006;
    /*SI SE NOS VA A DESBORDAR ALGO*/
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    /*SI QUEREMOS BALANCEAR UN TEXTO*/
    text-wrap: balance;
    /*SI QUEREMOS BALANCEAR UN PARRAFO*/
    text-wrap: pretty;
}


16. OBJECT FIT Y OBJECT POSITION
------------------------------------

Object FIT sirve para cuando nosotros definimos la altura y el ancho de un elemento, ese elemento también tiene un contenido. Si ponemos una imagen y definimos una altura, ¿qué va a pasar con nuestra imagen? Object fit va a solucionar eso, cómo se comportara el contenido de un objeto de este tipo cuando definimos su alto y su ancho.

Cargamos una imagen y definimos lo siguiente:

img{
    width: 400px;
    height: 200px;
}

La imagen se ve rara. Para solucionarlo definimos un object-fit. Propiedad por defecto es fill, se adapta rellenando el contenido. Contain hace lo mismo que una imagen con background contain, pero supongo que es mejor usar object-fit. Hacía que la imagen entre por lo menos una vez en la resolución que le dimos. Cover se adapta, también lo vimos. Tenemos también object fit none, que mantiene la resolución inicial de la imagen. No se ajsuta al contenido, sale la misma resolución. Por último, tenemos scale-down que lo que hace es que si nosotros le damos una resolución mayor a la imagen, se va a quedar con la resolución inicial, si le damos una resolución menor que la resolución original, se queda con la de resolución menor. Detecta la más pequeña.

Después tenemos object position: top, bottom, left, right,center o incluso pixeles para que nos muestre la parte de arriba, abajo izquierda o derecha de una foto. 

Todo esto NO SE APLICA A LOS FONDOS, SE APLICA A ELEMENTOS COMO IMAGENES O VÍDEOS!!!!!

17. CONTORNO/OUTLINE
----------------------

Se pudo haber explicado cuando vimos el box-model.

Si nosotros por ejemplo le aplicamos un borde a una caja, el borde AFECTA AL TAMÑO DE LA CAJA.

Si tenemos un input cualquiera, vemos que el input cuando lo clicamos tiene un borde predeterminado QUE NO PODEMOS CAMBIAR ni aun haciendo lo siguiente:

input{
    border: 2px solid #000;
}

input:focus{
    border: 2px solid    #000;
}

input:active{
    border: 2px solid    #000;
}

Permanece siempre un borde predefinido que tiene. Lo que vemos es EL OUTLINE.

En el modelo de caja nos falto decir que ENTRE EL MARGIN Y LOS BORDES estaba el CONTORNO/OUTLINE. Al darle padding a la caja adquiere más tamaño y lo mismo con el resto (borde).

De outline tenemos distintas propiedades: outline, outline-color,outline-width, outline-style y outline-offset. Tenemos que definir su width, color y estilo (solid) (como en el borde) para que pueda aparecer; la clave de outline es que NO OCUPA ESPACIO. No cambia el tamaño de la caja. Si cambiamos el borde si cambia el tamaño, pero si cambiamos el outline, el tamaño permanece igual.

Outline-offset, define el desplazamiento del contorno. Cuanto se separa del borde. Solamente es una propiedad visual, no ocupa espacio.

Lo podemos escribir todo en una linea menos el offset, que lo necesitaríamos poner en otra:

 outline: 5px solid #00f;

Funciona como el borde. Lo podemos utilizar con hover. Es muy útil para saber que esta seleccionando el user.

Si hacemos lo del hover PERO CON EL BORDER -> CAMBIA EL TAMAÑO DE LA CAJA, lo cual es probable que NO lo queramos hacer. Muy bueno para las transiciones, cambios de estado...

Si no quisiéramos que un input tenga un contorno, es muy sencillo, simplemente ponemos outline: none.
input{
    margin:50px;
    border: none;
    border-top: 3px solid #000;
}

input:focus{
    border-color: #00f;
    color: #00f;    
    outline: none;
}

PERO HACER ESTO ESTÁ FATAL. PORQUE CON ESTO TENEMOS PROBLEMAS DE ACCESIBILIDAD!!!! MUY IMPORTANTE!!! DONDE LO DEBERÍAMOS DE HACER ES EN LA PSEUDO-CLASE :FOCUS-VISIBLE:

input{
    margin:50px;
    border: none;
    border-top: 3px solid #000;
}

input:focus{
    border-color: #00f;
    color: #00f;    
}

input:focus-visible{
    outline:none ;
}

Esto último es MUY IMPORTANTE.

18. EMMET
--------------

Lo explica en un vídeo que ya está subido en su canal. Es un plug-in que nos sirve para facilitar la creación de ciertos elementos de HTML y CSS.

Sirve para hacer cosas como li*4... crear elementos mucho más rápido. Nos permite crear código directamente a través de abreviaciones.

Esto pasa cuando usamos las etiquetas, cuando usamos lorem… 

Si por ejemplo queremos crear un unordered-list con 4 list ponemos lo siguiente:

ul>li*4 

Si además queremos poner dentro de cada li queremos poner un enlace a hacemos: ul> li*4>a. Podemos crear estas estructuras desde 0.

También lo podemos hacer de la siguiente manera: ul>(li>a)*4. El proceso de creación es distinto a nivel interno, pero el resultado es el mismo.

Además también le podemos dar clases. Poniendo después del elemento al que queramos añadir una clase .nombre_clase.

Por ejemplo: ul>(li>a.link)*4 que dice que cada enlace a tendrá la clase link. Si ponemos # crea un id. Crear más de un elemento con un mismo id es una MALA PRÁCTICA para luego JS.

   <!--Si queremos una estructura semánticamente correcta-->
    header.header>nav.header-nav>ul.header-ul>(li.list-item>a.link)*4

Si queremos que un elemento tenga contenido lo que hacemos es usar {}: header.header>nav.header-nav>ul.header-ul>(li.list-item>a.link{Conio})*4 Le ponemos que el contenido sea Conio.

Si por ejemplo queremos que al contenido se le añada un número con el número de elemento de la ul lo hacemos con el símbolo del dollar $: header.header>nav.header-nav>ul.ul-nav>li.list-item*4>a.link{Link $}  

Cada repetición valdrá uno más.

Para poder crear los propios atributos de la etiqueta debemos poner :atributo, por ejemplo img:src para que se ponga el src (ya vendría por defecto.).

Nosotros podemos crear nuestros propios "snippet" de EMMET. Para ello copiamos el atajo que queramos, hacemos ctrl+shift+p y buscamos snippets. Buscar el que NOSOTROS YA HEMOS CREADO QUE ES html.json.snippet.

Una vez creamos nuestro snippet tenemos que borrar el último carácter y escribirlo de nuevo, lo cual es medio pesado. Ya lo he creado de forma que no sea pesado. 

IMPORTANTE: CTRL+SHIFT+P BUSCAMOS SNIPPET -> CONFIGURAR SNIPPET -> HTML.json-snippet , copiamos la estructura y creamos los snippet que nosotros queramos. Para ir pasando entre los href podemos usar simplemente el tabulador para ir rellenándolo.

En CSS es muchísimo más sencillo. Para el margen de una etiqueta podemos poner m10 y nos pone margin:10px; directamente. Si ponemos m10p p= porcentaje, si ponemos e=em. Si queremos darle margin 10 y 10 hacemos m10-10

Lo mismo sirve para el padding poniendo p. Width con w. Height con h. Igual con color.

LE PODEMOS PEDIR A CHAT GPT QUE NOS HAGA UNA LISTA ED LOS EMMETS MÁS UTILIZADOS Y COPIARLA EN EL ARCHIVO JSON QUE HEMOS CREADO.

Utilizar muchos EMMETS
